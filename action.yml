name: 'Crunchy Database Deployment'
description: 'Deploy a Crunchy PostgreSQL database to OpenShift'

inputs:
  directory:
    description: 'Crunchy Chart directory'
    default: 'charts/crunchy'
    required: false
  oc_server:
    description: 'OpenShift server'
    default: 'https://api.silver.devops.gov.bc.ca:6443'
    required: false
  environment:
    description: 'Environment name; omit for PRs'
    required: false
  values_file:
    description: 'Path to the values.yml file to use for the deployment'
    required: true
  enabled:
    description: 'Enable the deployment of the crunchy database, easy switch to turn it on/off'
    default: 'true'
    required: false
  triggers:
    description: 'Paths used to trigger a deployment; e.g. (./backend/ ./frontend/)'
    required: false
  ref:
    # This should be an empty string by default, but can be set to a specific branch/tag/sha
    description: 'Git ref to use; e.g. branch, tag, sha'
    default: ''
    required: false
  oc_namespace:
    description: 'OpenShift namespace'
    required: true
  oc_token:
    description: 'OpenShift token'
    required: true
  s3_access_key:
    description: 'S3 access key'
    required: false
  s3_secret_key:
    description: 'S3 secret key'
    required: false
  s3_bucket:
    description: 'S3 bucket'
    required: false
  s3_endpoint:
    description: 'S3 endpoint'
    required: false

runs:
  using: "composite"
  steps:
    - if: github.event.action != 'closed'
      shell: bash
      run: |
        # Variables and Inputs

        # Release and cluster names; based on a hash of the repository name
        RELEASE_NAME=pg-$(echo -n "${{github.event.repository.name}}" | md5sum | cut -c 1-8)
        CLUSTER_NAME=${RELEASE_NAME}-crunchy

        # Enable S3 backups if all required vars are set
        s3_vars=("${{ inputs.s3_access_key }}" "${{ inputs.s3_secret_key }}" "${{ inputs.s3_bucket }}" "${{ inputs.s3_endpoint }}")
        if [ "${#s3_vars[@]}" -eq 4 ]; then
          echo "All S3 configuration variables are present. Enabling S3 backups."
          S3_ENABLED=true
        elif [ "$s3_vars_count" -gt 0 ]; then
          echo "Warning: Some S3 configuration variables are set, but not all. Please ensure all S3 variables are configured."
          exit 1
        else
          echo "S3 configuration not set. Disabling S3 backups."
        fi

        # Validate values.yml URL
        if ! curl --output /dev/null --silent --head --fail "${VALUES_URL}"; then
          echo "Error: The constructed values.yml URL is invalid or inaccessible: ${VALUES_URL}"
          exit 1
        fi
        echo "Validated values.yml URL: ${VALUES_URL}"

        # Process vars and send to GITHUB_ENV
        for var in "${S3_ENABLED RELEASE_NAME CLUSTER_NAME VALUES_URL}"; do
          if [ -n "${!var}" ]; then
            echo "${var}=${!var}"
            echo "${var}=${!var}" >> $GITHUB_ENV
          else
            echo "Warning: ${var} is not set."
            exit 1
          fi
        done

    - uses: actions/checkout@v4
      if: github.event.action != 'closed'

    - uses: bcgov/action-oc-runner@v1.2.1
      id: deploy
      if: github.event.action != 'closed' # avoid running on PR close event, which unnecessarily patches the cluster.
      with:
        oc_namespace: "${{ inputs.oc_namespace }}"
        oc_token: "${{ inputs.oc_token }}"
        oc_server: "${{ inputs.oc_server }}"
        repository: ${{ github.repository }}
        ref: ${{ inputs.ref }}
        triggers: "${{ inputs.triggers }}"
        commands: |
          # Deploy Database
          echo 'Deploying crunchy helm chart'
          cd ${{ inputs.directory }}

          # Download values.yml file
          curl -o ./values.yml "${VALUES_URL}"
          echo "Downloaded values.yml (current directory: charts/crunchy)"

          # Set Helm app name
          sed -i 's/^name:.*/name: ${{ github.event.repository.name }}/' Chart.yaml

          # Package, update and deploy the chart
          helm package -u .
          if [ "$s3_enabled" == "true" ]; then
            helm upgrade --install --wait --set crunchy.pgBackRest.s3.enabled=true \
              --set-string crunchy.pgBackRest.s3.accessKey=${{ inputs.s3_access_key }} \
              --set-string crunchy.pgBackRest.s3.secretKey=${{ inputs.s3_secret_key }} \
              --set-string crunchy.pgBackRest.s3.bucket=${{ inputs.s3_bucket }} \
              --set-string crunchy.pgBackRest.s3.endpoint=${{ inputs.s3_endpoint }} \
              ${RELEASE_NAME} --values ./values.yml \
              ./${{ github.event.repository.name }}-5.5.1.tgz
          else
            helm upgrade --install --wait ${RELEASE_NAME} --values ./values.yml \
              ./${{ github.event.repository.name }}-5.5.1.tgz
          fi

          # Verify successful db deployment; wait retry 10 times with 60 seconds interval
          READY=false
          for i in {1..10}; do
            # Check if the 'db' instance has at least 1 ready replica
            if oc get PostgresCluster/${RELEASE_NAME}-crunchy -o json | jq -e '.status.instances[] | select(.name=="db") | .readyReplicas > 0' > /dev/null 2>&1; then
              echo "Crunchy DB instance 'db' is ready "
              READY=true
              break
            else
              echo "Attempt $i: Crunchy DB is not ready, waiting for 60 seconds"
              sleep 60
            fi
          done

          if [ "$READY" = false ]; then
            echo "Crunchy DB did not become ready after 10 attempts."
            exit 1
          fi

    - if: steps.deploy.outputs.triggered == 'true'
      shell: bash
      run: |
        # Add PR specific user to Crunchy DB
        echo "Adding PR specific user to Crunchy DB"
        NEW_USER='{"databases":["app-${{ github.event.number }}"],"name":"app-${{ github.event.number }}"}'
        CURRENT_USERS=$(oc get PostgresCluster/"${CLUSTER_NAME}" -o json | jq '.spec.users')
        echo "${CURRENT_USERS}"

        # check if current_users already contains the new_user
        if echo "${CURRENT_USERS}" | jq -e ".[] | select(.name == \"app-${{ github.event.number }}\")" > /dev/null; then
          echo "User already exists"
          exit 0
        fi

        UPDATED_USERS=$(echo "${CURRENT_USERS}" | jq --argjson NEW_USER "${NEW_USER}" '. + [$NEW_USER]')
        PATCH_JSON=$(jq -n --argjson users "${UPDATED_USERS}" '{"spec": {"users": $users}}')
        oc patch PostgresCluster/"${CLUSTER_NAME}" --type=merge -p "${PATCH_JSON}"
        # wait for sometime as it takes time to create the user, query the secret and check if it is created, otherwise wait in a loop for 5 rounds
        SECRET_FOUND=false
        for i in {1..5}; do
          if oc get secret "${CLUSTER_NAME}-pguser-app-${{ github.event.number }}" -o jsonpath='{.metadata.name}' > /dev/null 2>&1; then
            echo "Secret created"
            SECRET_FOUND=true
            break
          else
            echo "Attempt $i: Secret not created, waiting for 60 seconds"
            sleep 60
          fi
        done

        if [ "$SECRET_FOUND" = false ]; then
          echo "Error: Secret ${CLUSTER_NAME}-pguser-app-${{ github.event.number }} was not created after 5 attempts."
          exit 1
        fi

    - if: github.event.action == 'closed'
      uses: bcgov/action-oc-runner@v1.2.1
      with:
        oc_namespace: "${{ inputs.oc_namespace }}"
        oc_token: "${{ inputs.oc_token }}"
        oc_server: "${{ inputs.oc_server }}"
        triggers: "${{ inputs.triggers }}"
        commands: |
          # Remove PR specific user from Crunchy DB

          # Cluster name; based on a hash of the repository name
          CLUSTER_NAME=pg-$(echo -n "${{github.event.repository.name}}" | md5sum | cut -c 1-8)-crunchy

          # Check if postgres-crunchy exists or else exit
          oc get PostgresCluster/"${CLUSTER_NAME}" || exit 0

          # Remove the user from the crunchy cluster yaml and apply the changes
          USER_TO_REMOVE='{"databases":["app-${{ github.event.number }}"],"name":"app-${{ github.event.number }}"}'
          
          echo 'getting current users from crunchy'
          CURRENT_USERS=$(oc get PostgresCluster/"${CLUSTER_NAME}" -o json | jq '.spec.users')
          echo "${CURRENT_USERS}"
          
          # Remove the user from the list, 
          UPDATED_USERS=$(echo "${CURRENT_USERS}" | jq --argjson user "${USER_TO_REMOVE}" 'map(select(. != $user))')
          PATCH_JSON=$(jq -n --argjson users "${UPDATED_USERS}" '{"spec": {"users": $users}}')
          oc patch PostgresCluster/"${CLUSTER_NAME}" --type=merge -p "${PATCH_JSON}"
          
          # get primary crunchy pod and remove the role and db
          CRUNCHY_PG_PRIMARY_POD_NAME=$(oc get pods -l postgres-operator.crunchydata.com/cluster="${CLUSTER_NAME}",postgres-operator.crunchydata.com/role=master -o json | jq -r '.items[0].metadata.name')
          
          echo "${CRUNCHY_PG_PRIMARY_POD_NAME}"
          # Terminate all connections to the database before trying terminate and Drop the databse and role right after
          oc exec -it "${CRUNCHY_PG_PRIMARY_POD_NAME}" -- bash -c "psql -U postgres -d postgres -c \"SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = 'app-${{ github.event.number }}' AND pid <> pg_backend_pid();\" && \psql -U postgres -d postgres -c \"DROP DATABASE \\\"app-${{ github.event.number }}\\\";\" && \psql -U postgres -d postgres -c \"DROP ROLE \\\"app-${{ github.event.number }}\\\";\""
          echo 'database and role deleted'
